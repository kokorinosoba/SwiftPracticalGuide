# Swiftはどのような言語か
## 1.1 言語の特徴
- 静的型付き言語
- nilの許容性をコントロール可能
  - nil: C#で言うnull
  - 初期化されていないことによる実行時エラーが発生する
  - 変数や定数に基本的にnilを代入できない
  - nilを許容するには`Optional<Wrapped>`を使う
- 型推論による簡潔な記述
  - コンパイラが型を推測できる場合は変数の宣言時に型を明示する必要はない
- ジェネリクスによる汎用的な記述
  - ジェネリクスを使うことで特定の型に制限されない汎用的なプログラムを記述できる
- Objective-Cと連携可能
  - Cocoa: iOS, tvOS, watchOSのアプリケーションを構築するためのプラットフォーム
  - Cocoaの大部分はObjective-Cで書かれているが、SwiftからCocoaの資産を利用可能

## 1.2 開発環境
- ツールチェインのインストール
  - ツールチェイン: コンパイラやデバッガーなどの開発に必要なツールをまとめたもの
  - ツールチェインはXcodeに含まれる
  - Xcodeをインストールすることでswiftも同時にインストールされる
  - `swift -version`で確認
- ライブラリ
  - 標準ライブラリとコアライブラリに分類される
  - 標準ライブラリ: 言語の一部として基本的な機能を提供するライブラリ
    - 数値、文字列、配列、辞書などのデータを表す型が提供されている
    - インポートは不要
  - コアライブラリ: 高機能な汎用ライブラリ
    - 非同期処理や通信、ファイル操作などの高レベルの機能を提供するライブラリ
    - Foundation: 多くのアプリケーションに必要となる機能を提供
    - libdispatch: マルチコアハードウェア上の並列処理を抽象化するライブラリ
    - XCTest: ユニットテストのためのライブラリ
- 開発ツール
  - Swiftのツールチェインには開発を円滑に進めるためのツールも同梱されている
  - Swift Package Manager
    - Swiftのパッケージを管理するツール
    - パッケージ: ソースコードをマニフェストファイルをまとめたもの
      - マニフェストファイル: パッケージ名や依存パッケージなどを記述するファイル
  - LLDB: デバッグツール

## 1.3 プログラムの実行方法
- コマンドラインによる実行方法
  - REPLによるインタラクティブな実行
    - 行の先頭に`:`をつけるとREPLのコマンドとして認識される
    - 終了するには`:exit`と入力する
  - 単一ファイルのプログラムの実行
    - `swift 実行ファイル名`
  - 複数のファイルから構成されるプログラムの実行
    - 複数のファイルから成るプログラムを開発する場合はSwift Package Managerを使用する
    - パッケージを記述するマニフェストファイルや所定のディレクトリを用意しておくとSwift Package Managerはこれらを組み合わせてプログラムを実行する
    - Swift Package Managerにはパッケージをセットアップするコマンドがあるので簡単
    - `swift package init --type executable`
      - 実行ファイルのパッケージに必要なディレクトリやファイルを生成する
      - `Package.swift`: パッケージ名や依存パッケージなどを記述するマニフェストファイル
      - `Sources/DIR_NAME`: ビルドされる実行ファイルのソースコード
      - `Tests/DIR_NAMETests`: テストのソースコード
      - プログラムのエントリポイントは`Sources/DIR_NAME/main.swift`
      - `swift build`でビルドでき、`swift run`または`.build/debug/DIR_NAME`で実行
- Xcodeにおける実行方法
  - Playgroundによるインタラクティブな実行
    - Playgroundではファイルを編集しながら各業の結果を確認できる
    - Xcode > File > New > Playground (cmd+shift+opt+N)
  - 複数のファイルから構成されるプログラムの実行


## 1.5 命名規則
- 名前に使用可能な文字
  - 基本的には英語の名詞として読めるもの
- 単語の区切り方
  - ローワーキャメル(lowerCamelCase)
    - 変数、定数など
  - アッパーキャメル(UpperCamelCase)
    - 型など
- 単語の選び方
  - 簡潔さよりも明確さを重視する
  - 基本的な指針
    - 曖昧さの解消に必要な単語は全て含める
      - x: findUser(_:): 何を用いてユーザーIDを検索するのかが曖昧
      - o: findUser(byID:): ユーザーIDで検索することが明確
    - 一般的でない単語の仕様を避ける
      - x: epidermis
      - o: skin: 一般的かつepidermisと同様の意味の単語
    - 略語を避ける
      - x: stmt: statementの略語だがわかりにくい
      - o: statement

# 変数と定数と式
## 2.1 変数と定数による値の管理
- 変数と定数は値の一時的な保存に使う

## 2.2 変数と定数の基本
- 宣言方法
  - 変数: `var 変数名: 型名`
  - 定数: `let 定数名: 型名`
  - 型アノテーション: 変数や定数宣言時の型名を表す部分 (`: Int`など)
- 値の代入方法
  - `変数名または定数名 = 代入する値`
  - 式: 変数や定数、演算子などを組み合わせたもの
    - 値の変更、値の返却、もしくはその両方を行う
    - `a = 1`: 変数の値を変更する式
    - `1 + 1`: 値を返す式
    - 変数や定数は宣言と同時に値を代入することができる
      - `let a: Int = 123`
  - 代入可能な値
    - 変数や定数の型と一致しているもののみ
    - `let a: Int = "abc"`: コンパイルエラー
  - 代入による型推論
    - 変数や定数の宣言と同時に値を代入する場合、型を推論できる
    - `let a = "abc"`: 型アノテーションなし
    - 通常型推論が利用できるケースでは型アノテーションは省略し、型アノテーションがなければ変数や定数の型を決定できない場合にのみ型アノテーションを追加する
  - 定数への再代入
    - 定数は1度目の代入のみ認められ、再代入はできない
    - `let a: Int`
    - `a = 1`: OK
    - `a = 2`: 2度目の代入のためコンパイルエラー
  - 値の利用方法
    - 値を利用する箇所に変数名や定数名を記述することでその中身の値を返す
  - 初期化前の変数や定数の利用
    - 初期化: 変数や定数への最初の代入のこと
    - 初期化前に変数や定数を使おうとするとコンパイルエラーになる
- 型の確認方法
  - 型アノテーションや型推論によって決定された変数や定数の型を確認するにはtype(of:)関数を使用する
  - `type(of: 式)`
  - 例: `type(of: 123)`: Int.Type
  - Xcodeには変数や定数の型を表示するQuick Help機能がある
    - Help > Show Quick Help for Selected Item (ctrl+cmd+?): ポップアップで表示
    - View > Inspectors > Show Quick Help Inspector (opt+cmd+3): QuickHelpが右ペインに表示され、カーソルを合わせることで表示

## 2.3 スコープ
- スコープとは
  - 変数、定数、関数、型の名前の有効範囲を表す
  - グローバルスコープとローカルスコープが存在する
  - 同じスコープ内に同じ名前を複数存在させることはできず、変数、定数、関数、型の種類が異なっていても名前は一意である必要がある
- ローカルスコープ: 局所的に定義されるスコープ
  - 関数や制御構文によって定義されるスコープ
  - ローカルスコープで宣言された変数や定数は関数や制御構文が持つ実行分の内部のみで有効で、スコープの外部からは参照できない
- グローバルスコープ: プログラム全体から参照できるスコープ
  - どの関数にも型宣言にも含まれないスコープ
  - どこからでも参照できるため、意図しない変更を招きやすい
    - ローカルスコープで宣言された変数や定数よりも説明的な命名が必要となる
- スコープの優先順位
  - 同じスコープ内に同じ名前を複数存在させることはできないが、異なるスコープには同じ名前を存在させることができる
  - 異なるスコープに同一の名前が存在する場合、名前を参照するスコープから最も近い祖先のスコープにあるものが優先される

## 2.4 式の組み立て
- 式の分類
  - 値の返却のみを行う式
  - 演算を行う式
  - 処理を呼び出す式
- 値の返却のみを行う式
  - 変数や定数の値を返却する式
    - 変数名や定数名のみで構成され、四季の評価時に変数や定数に入っている値を返す
    - 例: `a`
  - リテラル式: 値をプログラムに直接表記する式
    - リテラル: 1や"abc"などの値をプログラムに直接表記する書式
    - 整数リテラルや文字列リテラルなどがある
    - リテラルで構成される式をリテラル式と言い、リテラル式はリテラルが表す値を返す
    - 例: `1`、`"abc"`
    - 基本的な値を表すリテラルはデフォルトの型を持ち、リテラルに対する型推論がされない箇所ではデフォルトの型の値を返す
    - 互換性のある別の型の値を返すことも可能
      - リテラル式の代入先の定数が型アノテーションで明示されている場合はリテラル式が返す値は代入先と同じ型であると推論される
      - 例: `let a: Int64 = 1`: aはInt64型
    - 推論された型がリテラル式と互換性がない場合はコンパイルエラーとなる
      - 例: `let a: String = 1`: コンパイルエラー
    - デフォルトの型を持たないリテラル
      - 配列リテラル、辞書リテラル、nilリテラル
  - メンバー式: 型のメンバーにアクセスする式
    - 型の値や型自身に紐づく変数、定数、関数、型などのこと
      - 例: `式.メンバー名`
    - プロパティ: 値に紐づく変数や定数
    - メソッド: 型に紐づく関数
  - クロージャー式: 呼び出し可能な処理を定義する式
    - クロージャー: 処理をまとめて呼び出し可能にしたもの
    - クロージャーの入力値を引数と言い、出力値を戻り値と言う
    - クロージャー式
      - クロージャーを定義する式で、処理を即席的に定義して他の処理に渡す際に使用する
      - 式の値は定義したクロージャーとなる
    - 様々な書き方があるが、代表的なものは下記
      - `{ 引数 in 戻り地を返す式 }`
      - 例: `[1, 2, 3].map({ value in value * 2 })`: 配列の各要素を2倍するクロージャーを渡している
- 演算を行う式
  - 演算子の種類に応じた演算を行い、演算結果の値を返す
  - 配置位置によって前置演算子、中置演算子、後置演算子に分けられる
    - 前置演算子: `-a`
    - 中置演算子: `a + b`
    - 後置演算子: `a!`
  - 算術演算子: 算術を行う演算子
    - 演算子に応じた算術を行う中置演算子
    - `+`, `-`, `*`, `/`, `%`など
    - 算術演算子の両辺の式の型は一致している必要がある
      - 例:
      - `let int = 27`
      - `let double = 0.3`
      - `int * double`: コンパイルエラー
    - 異なる型の値に対する演算を行うにはどちらか一方をもう一方の型の値に変換する
      - `Double(int) * double`
    - 暗黙的な型変換による想定外の桁の損失を防ぐというメリットがある
  - 符号演算子: 数値の符号を指定する演算子
    - 符号演算子`-`は数値のプラスとマイナスの符号を反転する前置演算子
    - 例: `-a`: (aはInt型やDouble型などの数値を表す型)
  - 否定演算子
    - 否定演算子`!`は真理値を反転する前置演算子
    - 例: `!a`: (aは真理値型=Bool型)
- 処理を呼び出す式
  - 関数を呼び出す式
    - 関数: 処理をまとめて呼び出し可能にしたもの
      - `関数名(引数名1: 引数1, 引数名2: 引数2, ...)`
    - 関数の入力値を引数と言い、出力値を戻り値と言う
    - 関数の呼び出しは式であり、式が返す値は関数の戻り値となる
    - 例: `max(2, 7)`
  - イニシャライザーを呼び出す式
    - イニシャライザー: 型のインスタンスを生成するための処理をまとめたもの
      - `型名(引数名1: 引数1, 引数名2: 引数2, ...)`
    - 型は値の種類であり、型のインスタンスは具体的な値を表すもの
    - イニシャライザーの呼び出しは式であり、式が返す値は生成したインスタンスとなる
    - 例: `String(4)`: String型のイニシャライザーにInt型の4を渡すことでString型に変換された"4"を値として返している
