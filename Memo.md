# Swiftはどのような言語か
## 1.1 言語の特徴
- 静的型付き言語
- nilの許容性をコントロール可能
  - nil: C#で言うnull
  - 初期化されていないことによる実行時エラーが発生する
  - 変数や定数に基本的にnilを代入できない
  - nilを許容するには`Optional<Wrapped>`を使う
- 型推論による簡潔な記述
  - コンパイラが型を推測できる場合は変数の宣言時に型を明示する必要はない
- ジェネリクスによる汎用的な記述
  - ジェネリクスを使うことで特定の型に制限されない汎用的なプログラムを記述できる
- Objective-Cと連携可能
  - Cocoa: iOS, tvOS, watchOSのアプリケーションを構築するためのプラットフォーム
  - Cocoaの大部分はObjective-Cで書かれているが、SwiftからCocoaの資産を利用可能

## 1.2 開発環境
- ツールチェインのインストール
  - ツールチェイン: コンパイラやデバッガーなどの開発に必要なツールをまとめたもの
  - ツールチェインはXcodeに含まれる
  - Xcodeをインストールすることでswiftも同時にインストールされる
  - `swift -version`で確認
- ライブラリ
  - 標準ライブラリとコアライブラリに分類される
  - 標準ライブラリ: 言語の一部として基本的な機能を提供するライブラリ
    - 数値、文字列、配列、辞書などのデータを表す型が提供されている
    - インポートは不要
  - コアライブラリ: 高機能な汎用ライブラリ
    - 非同期処理や通信、ファイル操作などの高レベルの機能を提供するライブラリ
    - Foundation: 多くのアプリケーションに必要となる機能を提供
    - libdispatch: マルチコアハードウェア上の並列処理を抽象化するライブラリ
    - XCTest: ユニットテストのためのライブラリ
- 開発ツール
  - Swiftのツールチェインには開発を円滑に進めるためのツールも同梱されている
  - Swift Package Manager
    - Swiftのパッケージを管理するツール
    - パッケージ: ソースコードをマニフェストファイルをまとめたもの
      - マニフェストファイル: パッケージ名や依存パッケージなどを記述するファイル
  - LLDB: デバッグツール

## 1.3 プログラムの実行方法
- コマンドラインによる実行方法
  - REPLによるインタラクティブな実行
    - 行の先頭に`:`をつけるとREPLのコマンドとして認識される
    - 終了するには`:exit`と入力する
  - 単一ファイルのプログラムの実行
    - `swift 実行ファイル名`
  - 複数のファイルから構成されるプログラムの実行
    - 複数のファイルから成るプログラムを開発する場合はSwift Package Managerを使用する
    - パッケージを記述するマニフェストファイルや所定のディレクトリを用意しておくとSwift Package Managerはこれらを組み合わせてプログラムを実行する
    - Swift Package Managerにはパッケージをセットアップするコマンドがあるので簡単
    - `swift package init --type executable`
      - 実行ファイルのパッケージに必要なディレクトリやファイルを生成する
      - `Package.swift`: パッケージ名や依存パッケージなどを記述するマニフェストファイル
      - `Sources/DIR_NAME`: ビルドされる実行ファイルのソースコード
      - `Tests/DIR_NAMETests`: テストのソースコード
      - プログラムのエントリポイントは`Sources/DIR_NAME/main.swift`
      - `swift build`でビルドでき、`swift run`または`.build/debug/DIR_NAME`で実行
- Xcodeにおける実行方法
  - Playgroundによるインタラクティブな実行
    - Playgroundではファイルを編集しながら各業の結果を確認できる
    - Xcode > File > New > Playground (cmd+shift+opt+N)
  - 複数のファイルから構成されるプログラムの実行


## 1.5 命名規則
- 名前に使用可能な文字
  - 基本的には英語の名詞として読めるもの
- 単語の区切り方
  - ローワーキャメル(lowerCamelCase)
    - 変数、定数など
  - アッパーキャメル(UpperCamelCase)
    - 型など
- 単語の選び方
  - 簡潔さよりも明確さを重視する
  - 基本的な指針
    - 曖昧さの解消に必要な単語は全て含める
      - x: findUser(_:): 何を用いてユーザーIDを検索するのかが曖昧
      - o: findUser(byID:): ユーザーIDで検索することが明確
    - 一般的でない単語の仕様を避ける
      - x: epidermis
      - o: skin: 一般的かつepidermisと同様の意味の単語
    - 略語を避ける
      - x: stmt: statementの略語だがわかりにくい
      - o: statement

# 変数と定数と式
## 2.1 変数と定数による値の管理
- 変数と定数は値の一時的な保存に使う

## 2.2 変数と定数の基本
- 宣言方法
  - 変数: `var 変数名: 型名`
  - 定数: `let 定数名: 型名`
  - 型アノテーション: 変数や定数宣言時の型名を表す部分 (`: Int`など)
- 値の代入方法
  - `変数名または定数名 = 代入する値`
  - 式: 変数や定数、演算子などを組み合わせたもの
    - 値の変更、値の返却、もしくはその両方を行う
    - `a = 1`: 変数の値を変更する式
    - `1 + 1`: 値を返す式
    - 変数や定数は宣言と同時に値を代入することができる
      - `let a: Int = 123`
  - 代入可能な値
    - 変数や定数の型と一致しているもののみ
    - `let a: Int = "abc"`: コンパイルエラー
  - 代入による型推論
    - 変数や定数の宣言と同時に値を代入する場合、型を推論できる
    - `let a = "abc"`: 型アノテーションなし
    - 通常型推論が利用できるケースでは型アノテーションは省略し、型アノテーションがなければ変数や定数の型を決定できない場合にのみ型アノテーションを追加する
  - 定数への再代入
    - 定数は1度目の代入のみ認められ、再代入はできない
    - `let a: Int`
    - `a = 1`: OK
    - `a = 2`: 2度目の代入のためコンパイルエラー
  - 値の利用方法
    - 値を利用する箇所に変数名や定数名を記述することでその中身の値を返す
  - 初期化前の変数や定数の利用
    - 初期化: 変数や定数への最初の代入のこと
    - 初期化前に変数や定数を使おうとするとコンパイルエラーになる
- 型の確認方法
  - 型アノテーションや型推論によって決定された変数や定数の型を確認するにはtype(of:)関数を使用する
  - `type(of: 式)`
  - 例: `type(of: 123)`: Int.Type
  - Xcodeには変数や定数の型を表示するQuick Help機能がある
    - Help > Show Quick Help for Selected Item (ctrl+cmd+?): ポップアップで表示
    - View > Inspectors > Show Quick Help Inspector (opt+cmd+3): QuickHelpが右ペインに表示され、カーソルを合わせることで表示

## 2.3 スコープ
- スコープとは
  - 変数、定数、関数、型の名前の有効範囲を表す
  - グローバルスコープとローカルスコープが存在する
  - 同じスコープ内に同じ名前を複数存在させることはできず、変数、定数、関数、型の種類が異なっていても名前は一意である必要がある
- ローカルスコープ: 局所的に定義されるスコープ
  - 関数や制御構文によって定義されるスコープ
  - ローカルスコープで宣言された変数や定数は関数や制御構文が持つ実行分の内部のみで有効で、スコープの外部からは参照できない
- グローバルスコープ: プログラム全体から参照できるスコープ
  - どの関数にも型宣言にも含まれないスコープ
  - どこからでも参照できるため、意図しない変更を招きやすい
    - ローカルスコープで宣言された変数や定数よりも説明的な命名が必要となる
- スコープの優先順位
  - 同じスコープ内に同じ名前を複数存在させることはできないが、異なるスコープには同じ名前を存在させることができる
  - 異なるスコープに同一の名前が存在する場合、名前を参照するスコープから最も近い祖先のスコープにあるものが優先される

## 2.4 式の組み立て
- 式の分類
  - 値の返却のみを行う式
  - 演算を行う式
  - 処理を呼び出す式
- 値の返却のみを行う式
  - 変数や定数の値を返却する式
    - 変数名や定数名のみで構成され、四季の評価時に変数や定数に入っている値を返す
    - 例: `a`
  - リテラル式: 値をプログラムに直接表記する式
    - リテラル: 1や"abc"などの値をプログラムに直接表記する書式
    - 整数リテラルや文字列リテラルなどがある
    - リテラルで構成される式をリテラル式と言い、リテラル式はリテラルが表す値を返す
    - 例: `1`、`"abc"`
    - 基本的な値を表すリテラルはデフォルトの型を持ち、リテラルに対する型推論がされない箇所ではデフォルトの型の値を返す
    - 互換性のある別の型の値を返すことも可能
      - リテラル式の代入先の定数が型アノテーションで明示されている場合はリテラル式が返す値は代入先と同じ型であると推論される
      - 例: `let a: Int64 = 1`: aはInt64型
    - 推論された型がリテラル式と互換性がない場合はコンパイルエラーとなる
      - 例: `let a: String = 1`: コンパイルエラー
    - デフォルトの型を持たないリテラル
      - 配列リテラル、辞書リテラル、nilリテラル
  - メンバー式: 型のメンバーにアクセスする式
    - 型の値や型自身に紐づく変数、定数、関数、型などのこと
      - 例: `式.メンバー名`
    - プロパティ: 値に紐づく変数や定数
    - メソッド: 型に紐づく関数
  - クロージャー式: 呼び出し可能な処理を定義する式
    - クロージャー: 処理をまとめて呼び出し可能にしたもの
    - クロージャーの入力値を引数と言い、出力値を戻り値と言う
    - クロージャー式
      - クロージャーを定義する式で、処理を即席的に定義して他の処理に渡す際に使用する
      - 式の値は定義したクロージャーとなる
    - 様々な書き方があるが、代表的なものは下記
      - `{ 引数 in 戻り地を返す式 }`
      - 例: `[1, 2, 3].map({ value in value * 2 })`: 配列の各要素を2倍するクロージャーを渡している
- 演算を行う式
  - 演算子の種類に応じた演算を行い、演算結果の値を返す
  - 配置位置によって前置演算子、中置演算子、後置演算子に分けられる
    - 前置演算子: `-a`
    - 中置演算子: `a + b`
    - 後置演算子: `a!`
  - 算術演算子: 算術を行う演算子
    - 演算子に応じた算術を行う中置演算子
    - `+`, `-`, `*`, `/`, `%`など
    - 算術演算子の両辺の式の型は一致している必要がある
      - 例:
      - `let int = 27`
      - `let double = 0.3`
      - `int * double`: コンパイルエラー
    - 異なる型の値に対する演算を行うにはどちらか一方をもう一方の型の値に変換する
      - `Double(int) * double`
    - 暗黙的な型変換による想定外の桁の損失を防ぐというメリットがある
  - 符号演算子: 数値の符号を指定する演算子
    - 符号演算子`-`は数値のプラスとマイナスの符号を反転する前置演算子
    - 例: `-a`: (aはInt型やDouble型などの数値を表す型)
  - 否定演算子
    - 否定演算子`!`は真理値を反転する前置演算子
    - 例: `!a`: (aは真理値型=Bool型)
- 処理を呼び出す式
  - 関数を呼び出す式
    - 関数: 処理をまとめて呼び出し可能にしたもの
      - `関数名(引数名1: 引数1, 引数名2: 引数2, ...)`
    - 関数の入力値を引数と言い、出力値を戻り値と言う
    - 関数の呼び出しは式であり、式が返す値は関数の戻り値となる
    - 例: `max(2, 7)`
  - イニシャライザーを呼び出す式
    - イニシャライザー: 型のインスタンスを生成するための処理をまとめたもの
      - `型名(引数名1: 引数1, 引数名2: 引数2, ...)`
    - 型は値の種類であり、型のインスタンスは具体的な値を表すもの
    - イニシャライザーの呼び出しは式であり、式が返す値は生成したインスタンスとなる
    - 例: `String(4)`: String型のイニシャライザーにInt型の4を渡すことでString型に変換された"4"を値として返している

# 基本的な型
## 3.1 型による値の表現
- 型とは
  - 値の特性と値への操作を表現したもの
  - 例
    - Bool型、Int型、Float型、Double型、String型などの基本型がある
    - Optional<_Wrapped_>型: 値があるか空かのいずれかを表す
    - Any: 任意の値を表す
    - タプル型: 複数の型をまとめる
## 3.2 Bool型
- 真理値リテラル
  - 真を表すtrue, 偽を表すfalseがある
  - 真理値リテラルのデフォルトの型はBool型であり、式が型推論されない場合はBool型の値を返す
- 論理演算
  - 否定: `!true`: false, `!false`: true
  - 論理積: `false && false`: false, `true && false`: false, `true && true`: true
  - 論理和: `false || false`: false, `true || false`: true, `true || true`: true

## 3.3 数値型
- 数値リテラル
  - `123`: Int型, `1.0`: Double型
  - 数値リテラルのデフォルトの型はInt
  - 浮動小数点リテラルのデフォルトの型はDouble
- 数値型の種類
  - 整数型: Int, Int8, Int16, Int32, Int64
    - 最大値や最小値はそれぞれmax, minというスタティックプロパティでアクセスできる
  - 浮動小数点型: Float(32ビット), Double(64ビット)
    - 最大値や最小値のスタティックプロパティは用意されていない
    - CGFloat型はプラットフォームのビット数によってFloat型かDouble型かが変わる
    - CLLocationDegrees型はより高い精度が求められるため、プラットフォームによらずDouble型になる
    - 型エイリアス
      - CGFloatやCLLocationDegrees型はFloat型やDouble型の別名であり、型エイリアスと呼ばれる
      - 型エイリアスの定義方法: `typealias 新しい型名 = 型名`
      - 例: `typealias CLLocationDegrees = Double`
    - 浮動小数点型はスタティックプロパティとして無限大を表す`infinity`を持っている
      - 浮動小数点型に対する演算結果が無限大となった場合、その値はinfinityとなる
      - `isInfinity`というプロパティで無限大かどうかを判定できる
    - 非数を表す`nan`(NaN: Not a Number)もスタティックプロパティとして持っている
      - 演算として不正な値が渡され演算ができなかった場合NaNとなる
      - `NaN`というプロパティで非数かどうかを判定できる
- 数値型どうしの相互変換
  - Swiftでは数値型同士や浮動小数点型どうしであっても型が異なれば代入できない
  - 数値型を他の数値型に変換するにはイニシャライザーを使用する
  - 生成したい型よりも精度の高い方から初期化すると生成した型の精度に合わせて端数処理が行われる
  - 例: `Int(1.99)`: 1
- 数値型の操作
  - 比較: `==`, `!=`, `>`, `>=`, `<`, `<=`
  - 算術: `+`, `-`, `*`, `/`, `%`
  - 比較や算術演算では両辺の型を一致させる必要があり、型が一致しない場合はコンパイルエラーとなる
  - 複合代入演算子: `+=`, `-=`, `*=`, `/=`, `%=`
- Foundationによる高度な操作
  - Swiftの標準ライブラリには三角関数などの高度な操作は用意されていない
  - FoundationにC言語のmath.h相当の数学関数が用意されており、`sin(_:)`などの三角関数や`log(_:)`などの対数関数を利用できる
  - 円周率はFloat型のスタティックプロパティ`pi`として定義されている

## 3.4 String型
- 文字列リテラル
  - `"abc"`のようにダブルクォートで文字列を囲むと文字列リテラルと解釈される
  - 文字列リテラルのデフォルトの型はString型
  - 特殊文字の表記
    - 文字列リテラルは`"`や改行などの文字をそのまま表現できないため、特殊文字を使って表現する
    - `\`(バックスラッシュ)を特別な文字として扱い、`\`から始まる文字列によって特殊文字を表現する
    - このような表現方法を一般にエスケープシーケンスと呼ぶ
    - Swiftの代表的なエスケープシーケンス
      - `\n`: ラインフィード
      - `\r`: キャリッジリターン
      - `\"`: ダブルクォート
      - `\'`: シングルクォート
      - `\\`: バックスラッシュ
      - `\0`: null文字
  - 文字列リテラル内での値の展開
    - `\()`というエスケープシーケンスを用いて値を文字列リテラル内で展開できる
    - 例: `"結果: \(result)"`: resultの中身が展開される
  - 複数行の文字列リテラル
    - 複数行にまたがる文字列を生成する場合はスリーダブルクォートで囲む
    - 例
      - `"""`
      - `複数行の`
      - `文字列リテラル`
      - `"""`
    - 複数行の文字列リテラルのインデントは終了の`"""`の位置が基準となる
      - 終了の`"""`よりも深い位置のスペースは文字列とみなされるため、リテラルから生成される文字列にも含まれる
    - 文字列内のスペースとコードのインデントの区別を明確にするため`"""`と文字列の位置関係には2つの制限がある
      - 文字列は`"""`とは別の行に書く
        - `"""`と同じ行に文字列が書かれている場合はコンパイルエラーとなる
      - 文字列は終了の`"""`と同じかそれよりも深い位置に書く
        - 終了の`"""`よりもインデントが浅い行はコンパイルエラーとなる
- 数値型との相互変換
  - String型と数値型の相互変換にはイニシャライザーを使用する
    - Int型の値をString型に変換する場合
      - 例: `String(123)`: "123"
    - String型の値をInt型に変換する場合
      - 例: `Int("123")`: 123
      - ただし、文字列は必ずしも数値のフォーマットになっているとは限らないので、Stringがたから数値型への変換は失敗する可能性があるため、Int型のイニシャライザーはnilとなり得る`Optional<Int>`型の値を返却する
      - 例: `Int("abc")`: nil
- String型の操作
  - 比較: `""`(Unicodeの正準等価に基づく)
  - 結合: `+`, `.append(_:)`
    - 例: `"abc".append("def")`: "abcdef"
  - Foundationによる高度な操作
    - Swiftの標準ライブラリには大文字と小文字を区別しない比較や文字列探索などの高度な操作は用意されていない
    - 高度な操作はコアライブラリのFoundationで提供されている
    - 例
      - 文字列感の順序の比較
        - `"abc".compare("ABC", options: String.CompareOptions.caseInsensitive)`: ComparisonResult.orderedSame
      - 文字列の探索
        - `"abc".range(of: "bc")`: 1から2の範囲を示す値

## 3.5 `Optional<Wrapped>`型
- `Optional<Wrapped>`型
  - 値があるかカラカのいずれかを表す型
  - nilを許容する必要がある場合に使用する
  - `Wrapped`はプレースホルダー型と言い、実際にはWrappedを具体的な型で置き換えて使用する
  - 例: `Optional<Int>`, `Optional<String>`
  - `Optional<Wrapped>`型のように`<>`(山括弧)内にプレースホルダー型を持つ型をジェネリック型と言う
  - `Optional<Wrapped>`型には`Wrapped?`と表記する糖衣構文(シンタックスシュガー)が用意されている
- `Optional<Wrapped>`型の2つのケース: 値の不在を表す.noneと値の存在を表す.some
  - `Optional<Wrapped>`型はWrapped型の値の存在と不在の2通りを表すことができ、この2つは列挙型として定義されている
    - `enum Optional<Wrapped> {`
    - `    case none`
    - `    case some(Wrapped)`
    - `}`
  - 列挙型とは複数の識別子をまとめる型で、それぞれの識別子をケースと言う
  - `Optional<Wrapped>`型は.noneと.someの2つのケースを定義している
    - .none: 値の不在(=nil): `Optional<Wrapped>.none` = `nil`
    - .some: Wrapped型の値の存在: `Optional<Wrapped>.some` = `Optional(値)`
    - 例
      - `print(".none: \(String(describing: Optional<Int>.none))")`: nil
      - `print(".some: \(String(describing: Optional<Int>.some(1)))")`: Optional(1)
- 型推論
  - `Optional<Wrapped>`型の.someの値を生成する場合、Wrapped型は.someに持たせる値から型推論できる
    - 例: `let some = Optional.some(1)`: `Optional<Int>型`
  - .noneを生成する場合は型推論の元となる値が存在しないため、そのままでは`<Wrapped>`を省略できない
    - 型アノテーションなどを用いて代入先の型を決定する必要がある
    - 例: `let none: Int? = Optional.none`: `Optional<Int>型`
- `Optional<Wrapped>`型の値の生成
  - 列挙型のケースとして生成する以外にも方法がある
    - `var a: Int?`
    - `a = nil`: nilリテラルによる.noneの生成
    - `a = Optional(1)`: イニシャライザーによる.someの生成
    - `a = 1`: 値の代入による.someの生成
    - 列挙型のケースとして生成する方法よりもシンプルに記述できるため、一般的にはこれらの生成方法が使われる
- `Optional<Wrapped>`型のアンラップ: 値の取り出し
  - `Optional<Wrapped>`型は値を持っていない可能性があるため、Wrapped型の変数や定数と同じ用に扱うことはできない
    - `Int?`型どうしの四則演算はコンパイルエラーとなる
      - 例: `Optional(1) + Optional(1)`
    - アンラップ
      - Wrapped型の値を取り出す操作
      - Wrapped型の値に対する操作を行うには`Optional<Wrapped>`型の値から`Wrapped`型の値を取り出す必要がある
      - 3つのアンラップの方法がある
        - オプショナルバインディング: if文による値の取り出し
          - 条件分岐文や繰り返し文の条件に`Optional<Wrapped>`型の値を指定する
          - 値の存在が保証されている分岐内ではWrapped型の値に直接アクセスすることができる
          - オプショナルバインディングはif-let文を用いて行う
            - `if let 定数名 = Optional<Wrapped>型の値 {`
            - `    値が存在する場合に実行される文`
            - `}`
        - `??`演算子: 値が存在しない場合のデフォルト値を指定する演算子
          - `Optional<Wrapped>`型に値が存在しない場合のデフォルト値を指定するには中置演算子`??`を使用する
            - 例: `Optional<Wrapped> ?? Wrapped`
            - 左辺の`Optional<Wrapped>`型が値を持っていればアンラップしたWrapped型の値を返す
            - 左辺の`Optional<Wrapped>`型が値を持っていなければ右辺のWrapped型の値を返す
        - 強制アンラップ: !演算子による`Optional<Wrapped>`型の値の取り出し
            - `!`演算子を使用して値を強制的に取り出すが、値が存在しない場合実行時エラーになる
            - 例: `Optional(1)! + Optional(1)!`
            - 強制アンラップは値がないケースを無視したシンプルなコードを可能にするが、実行時エラーの危険性もはらんでいる
            - 値の存在がよほど明らかな箇所や値が存在しなければプログラムを終了させたい箇所以外では強制アンラップの使用は避ける
- オプショナルチェイン: アンラップを伴わずに値のプロパティやメソッドにアクセス
  - `Optional<Wrapped>?.プロパティ名など`
    - 例: `Optional(1.0)?.isInfinite`
    - `Optional<Wrapped>`型の変数や定数がnilだった場合は?以降に記述されたプロパティやメソッドへのアクセスは行わずにnilが返却される
  - `map(_:)`メソッドと`flatMap(_:)`メソッド: アンラップを伴わずに値の変換を行うメソッド
    - `map(_:)`
      - メソッドの引数には値を変換するクロージャーを渡す
      - 型の値が存在すればクロージャーを実行して値を変換する
      - 型の値が存在しなければ何も行わない
      - 例: `Optional(17).map({ value in value * 2 })`: 34(`Optional<Int>`)
    - `flatMap(_:)`
      - メソッドの引数には値を変換するクロージャーを渡すが、クロージャーの戻り値は`Optional<Wrapped>`型となる
        - 例: `Optional("17").flatMap({ value in Int(value) })`: 17(`Optional<Int>`)
        - ここでのポイントは値の有無が不確かな定数に対し、更に値を返すか定かではない操作を行っていること
      - flatMapの代わりにmapメソッドを使用してしまうと最終的な結果は二重に`Optional<Wrap>`型に包まれた`Int??`型になってしまう
        - 例: `Optional("17").map({ value in Int(value) })`: 17(`Optional<Optional<Int>>`)
      - 二重に不確かな状態を一つにまとめてくれるのが`flatMap(_:)`メソッド
- 暗黙的にアンラップされた`Optional<Wrapped>`型
  - `Wrapped?`と表記する糖衣構文とは別に`Wrapped!`と表記する糖衣構文が用意されている
  - 値へのアクセス時に自動的に強制アンラップを行う型
  - `Wrapped?`も`Wrapped!`も同じ`Optional<Wrapped>`型のため、互いの値を代入することが可能
  - 強制アンラップ時にnilだった場合は実行時エラーが発生する
  - `Optional<Wrapped>`型の強制アンラップと同様に危険な側面を持っているため乱用すべきではない
- 値の取り出し方法の使い分け
  - 通常はオプショナルバインディング、`??`演算子、mapやflatMapメソッドを組み合わせて値を取り出すのが良い
    - 値が存在しないケースを考慮したコードを必ずどこかで書かなければWrapped型の値を取得できないため
  - 強制アンラップや暗黙的にアンラップされた`Optional<Wrapped>`型は値の存在が明らかな箇所や値が存在しなければプログラムを終了させたい箇所のみで使用するべき
    - `!`を目印に見つけることが可能

## 3.6 Any型
- Any型とは
  - 全ての方が暗黙的に準拠している特別なプロトコルとして実装されている
  - Any型の変数や定数にはどのような型の値も代入できるため、代入する値の型が決まっていない場合に使用する
    - 例: `let string: Any = "abc"`
  - Any型はリテラルやイニシャライザーでは生成できない
- Any型への代入による型の損失
  - Any型の変数や定数に代入すると元の型の情報は失われてしまい、元の型では可能だった操作ができなくなってしまう
  - 可能な限りAny型への代入は避け、型の情報を保つことが望ましい
